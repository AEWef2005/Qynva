#!/usr/bin/env python3
"""
Agent Router - Central coordinator for the agentic LLM framework
Generated by Agentic LLM Framework
"""
import argparse
import json
import os
import sys
import subprocess
from typing import Dict, List, Optional, Any
from datetime import datetime
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class AgentRouter:
    """
    Central router that coordinates between different agents in the framework
    """
    
    def __init__(self, config_path: str = "agents/configs/config.json"):
        self.config_path = config_path
        self.config = self.load_config()
        self.staging_dir = self.config.get("workflow", {}).get("staging_dir", "agents/staging")
        self.agents = {
            "planner": "agents/planner.py",
            "coder": "agents/coder.py", 
            "tester": "agents/tester.py"
        }
        
        # Ensure staging directory exists
        os.makedirs(self.staging_dir, exist_ok=True)
        
    def load_config(self) -> Dict:
        """Load configuration from JSON file"""
        if os.path.exists(self.config_path):
            with open(self.config_path, 'r') as f:
                return json.load(f)
        return {}
    
    def execute_workflow(self, task: str, language: str = "python") -> Dict:
        """
        Execute the complete development workflow for a given task
        
        Args:
            task: Description of the task to complete
            language: Target programming language
            
        Returns:
            Dictionary containing workflow results
        """
        logger.info(f"ðŸš€ Starting workflow for task: {task}")
        
        workflow_result = {
            "task": task,
            "language": language,
            "timestamp": datetime.now().isoformat(),
            "steps": [],
            "success": False,
            "outputs": {}
        }
        
        try:
            # Step 1: Plan the task
            logger.info("ðŸ“‹ Step 1: Planning task...")
            plan_result = self.run_agent("planner", [task])
            workflow_result["steps"].append({
                "step": 1,
                "agent": "planner",
                "action": "plan_task",
                "status": "completed" if plan_result.get("success") else "failed",
                "output": plan_result
            })
            
            if not plan_result.get("success"):
                logger.error("Planning failed, aborting workflow")
                return workflow_result
            
            # Step 2: Generate code
            logger.info("ðŸ”¨ Step 2: Generating code...")
            code_result = self.run_agent("coder", [task, "--language", language])
            workflow_result["steps"].append({
                "step": 2,
                "agent": "coder", 
                "action": "generate_code",
                "status": "completed" if code_result.get("success") else "failed",
                "output": code_result
            })
            
            # Step 3: Generate tests
            logger.info("ðŸ§ª Step 3: Generating tests...")
            # For tests, we need to find the generated code path
            code_path = self._find_latest_code_output()
            if code_path:
                test_result = self.run_agent("tester", [code_path, "--language", language])
                workflow_result["steps"].append({
                    "step": 3,
                    "agent": "tester",
                    "action": "generate_tests", 
                    "status": "completed" if test_result.get("success") else "failed",
                    "output": test_result
                })
            
            # Step 4: Commit changes (if auto_commit is enabled)
            if self.config.get("workflow", {}).get("auto_commit", False):
                logger.info("ðŸ’¾ Step 4: Committing changes...")
                commit_result = self.commit_staging_changes(task)
                workflow_result["steps"].append({
                    "step": 4,
                    "agent": "router",
                    "action": "commit_changes",
                    "status": "completed" if commit_result.get("success") else "failed", 
                    "output": commit_result
                })
            
            workflow_result["success"] = True
            logger.info("âœ… Workflow completed successfully")
            
        except Exception as e:
            logger.error(f"Workflow failed: {e}")
            workflow_result["error"] = str(e)
            
        return workflow_result
    
    def run_agent(self, agent_name: str, args: List[str]) -> Dict:
        """
        Run a specific agent with given arguments
        
        Args:
            agent_name: Name of the agent to run
            args: Arguments to pass to the agent
            
        Returns:
            Dictionary containing agent execution results
        """
        if agent_name not in self.agents:
            return {"success": False, "error": f"Unknown agent: {agent_name}"}
        
        agent_path = self.agents[agent_name]
        if not os.path.exists(agent_path):
            return {"success": False, "error": f"Agent file not found: {agent_path}"}
        
        try:
            # Run the agent
            cmd = [sys.executable, agent_path] + args
            logger.info(f"Running command: {' '.join(cmd)}")
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )
            
            return {
                "success": result.returncode == 0,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "returncode": result.returncode,
                "command": ' '.join(cmd)
            }
            
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Agent execution timed out"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def _find_latest_code_output(self) -> Optional[str]:
        """Find the most recently generated code output"""
        if not os.path.exists(self.staging_dir):
            return None
        
        code_dirs = [d for d in os.listdir(self.staging_dir) if d.startswith("code_")]
        if not code_dirs:
            return None
        
        # Sort by timestamp and get the latest
        latest_dir = sorted(code_dirs)[-1]
        return os.path.join(self.staging_dir, latest_dir)
    
    def commit_staging_changes(self, task: str) -> Dict:
        """
        Commit changes from staging area to git
        
        Args:
            task: Description of the task for commit message
            
        Returns:
            Dictionary containing commit results
        """
        try:
            # Check if there are changes to commit
            result = subprocess.run(
                ["git", "status", "--porcelain"],
                capture_output=True,
                text=True
            )
            
            if not result.stdout.strip():
                return {"success": True, "message": "No changes to commit"}
            
            # Add all changes
            subprocess.run(["git", "add", "."], check=True)
            
            # Generate commit message
            commit_msg = f"Generated by Agentic LLM Framework: {task}"
            
            # Commit changes
            subprocess.run(
                ["git", "commit", "-m", commit_msg],
                check=True
            )
            
            logger.info(f"âœ… Changes committed: {commit_msg}")
            return {"success": True, "message": commit_msg}
            
        except subprocess.CalledProcessError as e:
            return {"success": False, "error": f"Git operation failed: {e}"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def list_available_agents(self) -> List[str]:
        """List all available agents"""
        return list(self.agents.keys())
    
    def get_agent_info(self, agent_name: str) -> Dict:
        """Get information about a specific agent"""
        if agent_name not in self.agents:
            return {"error": f"Unknown agent: {agent_name}"}
        
        agent_path = self.agents[agent_name]
        return {
            "name": agent_name,
            "path": agent_path,
            "exists": os.path.exists(agent_path),
            "description": f"{agent_name.title()} Agent"
        }
    
    def health_check(self) -> Dict:
        """Perform health check on all agents"""
        health_status = {
            "timestamp": datetime.now().isoformat(),
            "overall_status": "healthy",
            "agents": {}
        }
        
        for agent_name in self.agents:
            agent_info = self.get_agent_info(agent_name)
            health_status["agents"][agent_name] = {
                "available": agent_info.get("exists", False),
                "path": agent_info.get("path"),
                "status": "healthy" if agent_info.get("exists") else "missing"
            }
        
        # Check if any agents are missing
        if any(not info["available"] for info in health_status["agents"].values()):
            health_status["overall_status"] = "degraded"
        
        return health_status

def main():
    parser = argparse.ArgumentParser(description="Agent Router - Central coordinator")
    
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # Workflow command
    workflow_parser = subparsers.add_parser("workflow", help="Execute complete workflow")
    workflow_parser.add_argument("task", help="Task description")
    workflow_parser.add_argument("--language", "-l", default="python", help="Programming language")
    
    # Agent command  
    agent_parser = subparsers.add_parser("agent", help="Run specific agent")
    agent_parser.add_argument("agent_name", help="Name of agent to run")
    agent_parser.add_argument("args", nargs="*", help="Arguments for the agent")
    
    # List command
    list_parser = subparsers.add_parser("list", help="List available agents")
    
    # Info command
    info_parser = subparsers.add_parser("info", help="Get agent information")
    info_parser.add_argument("agent_name", help="Name of agent")
    
    # Health command
    health_parser = subparsers.add_parser("health", help="Check agent health")
    
    # Commit command
    commit_parser = subparsers.add_parser("commit", help="Commit staging changes")
    commit_parser.add_argument("message", help="Commit message")
    
    # Config option for all commands
    parser.add_argument("--config", help="Path to config file", default="agents/configs/config.json")
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    router = AgentRouter(config_path=args.config)
    
    if args.command == "workflow":
        result = router.execute_workflow(args.task, args.language)
        print(json.dumps(result, indent=2))
        
    elif args.command == "agent":
        result = router.run_agent(args.agent_name, args.args)
        print(json.dumps(result, indent=2))
        
    elif args.command == "list":
        agents = router.list_available_agents()
        print("Available agents:")
        for agent in agents:
            print(f"  - {agent}")
            
    elif args.command == "info":
        info = router.get_agent_info(args.agent_name)
        print(json.dumps(info, indent=2))
        
    elif args.command == "health":
        health = router.health_check()
        print(json.dumps(health, indent=2))
        
    elif args.command == "commit":
        result = router.commit_staging_changes(args.message)
        print(json.dumps(result, indent=2))

if __name__ == "__main__":
    main()