#!/usr/bin/env python3
"""
Planner Agent - Core planning and task orchestration agent
Generated by Agentic LLM Framework
"""
import argparse
import json
import os
import sys
from typing import Dict, List, Optional
from datetime import datetime

class PlannerAgent:
    """
    The Planner Agent is responsible for breaking down high-level tasks
    into actionable development steps and coordinating the workflow.
    """
    
    def __init__(self, config_path: str = "agents/configs/config.json"):
        self.config_path = config_path
        self.config = self.load_config()
        self.staging_dir = "agents/staging"
        
    def load_config(self) -> Dict:
        """Load configuration from JSON file"""
        if os.path.exists(self.config_path):
            with open(self.config_path, 'r') as f:
                return json.load(f)
        return {
            "llm_providers": {
                "grok": {"api_key": "", "model": "grok-beta"},
                "openai": {"api_key": "", "model": "gpt-4"},
                "claude": {"api_key": "", "model": "claude-3-sonnet"}
            },
            "default_provider": "grok",
            "output_format": "markdown"
        }
    
    def plan_task(self, task_description: str) -> Dict:
        """
        Break down a high-level task into actionable steps
        
        Args:
            task_description: High-level description of the task to plan
            
        Returns:
            Dictionary containing the planned steps and metadata
        """
        print(f"ðŸ¤– Planning task: {task_description}")
        
        # This is a template structure - in a real implementation,
        # this would interface with the configured LLM provider
        plan = {
            "task": task_description,
            "timestamp": datetime.now().isoformat(),
            "planned_by": "Planner Agent",
            "steps": self._generate_plan_steps(task_description),
            "estimated_complexity": self._estimate_complexity(task_description),
            "suggested_agents": self._suggest_agents(task_description)
        }
        
        self._save_plan(plan)
        return plan
    
    def _generate_plan_steps(self, task: str) -> List[Dict]:
        """Generate detailed planning steps based on task description"""
        # Template steps - this would be enhanced with LLM integration
        base_steps = [
            {
                "step": 1,
                "action": "analyze_requirements",
                "description": f"Analyze requirements for: {task}",
                "agent": "planner",
                "status": "pending"
            },
            {
                "step": 2,
                "action": "design_solution",
                "description": "Design technical solution and architecture",
                "agent": "coder",
                "status": "pending"
            },
            {
                "step": 3,
                "action": "implement_code",
                "description": "Implement the designed solution",
                "agent": "coder",
                "status": "pending"
            },
            {
                "step": 4,
                "action": "create_tests",
                "description": "Create comprehensive tests",
                "agent": "tester",
                "status": "pending"
            },
            {
                "step": 5,
                "action": "review_code",
                "description": "Review implementation and tests",
                "agent": "reviewer",
                "status": "pending"
            }
        ]
        return base_steps
    
    def _estimate_complexity(self, task: str) -> str:
        """Estimate task complexity based on keywords and patterns"""
        complexity_indicators = {
            "high": ["kernel", "api", "architecture", "system", "framework"],
            "medium": ["feature", "integration", "workflow", "configuration"],
            "low": ["documentation", "fix", "update", "refactor"]
        }
        
        task_lower = task.lower()
        for level, keywords in complexity_indicators.items():
            if any(keyword in task_lower for keyword in keywords):
                return level
        return "medium"
    
    def _suggest_agents(self, task: str) -> List[str]:
        """Suggest which agents should be involved based on task type"""
        agents = ["planner"]  # Planner is always involved
        
        task_lower = task.lower()
        if any(word in task_lower for word in ["code", "implement", "develop", "build"]):
            agents.append("coder")
        if any(word in task_lower for word in ["test", "validate", "verify", "check"]):
            agents.append("tester")
        if any(word in task_lower for word in ["review", "analyze", "audit"]):
            agents.append("reviewer")
        if any(word in task_lower for word in ["docs", "documentation", "readme"]):
            agents.append("documenter")
            
        return agents
    
    def _save_plan(self, plan: Dict) -> None:
        """Save the generated plan to staging directory"""
        os.makedirs(self.staging_dir, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.staging_dir}/plan_{timestamp}.json"
        
        with open(filename, 'w') as f:
            json.dump(plan, f, indent=2)
        
        print(f"âœ… Plan saved to: {filename}")
    
    def list_plans(self) -> List[str]:
        """List all saved plans"""
        if not os.path.exists(self.staging_dir):
            return []
        
        plans = [f for f in os.listdir(self.staging_dir) if f.startswith("plan_") and f.endswith(".json")]
        return sorted(plans, reverse=True)
    
    def load_plan(self, plan_file: str) -> Optional[Dict]:
        """Load a specific plan file"""
        plan_path = os.path.join(self.staging_dir, plan_file)
        if os.path.exists(plan_path):
            with open(plan_path, 'r') as f:
                return json.load(f)
        return None

def main():
    parser = argparse.ArgumentParser(description="Planner Agent - Task planning and orchestration")
    parser.add_argument("task", nargs="?", help="Task description to plan")
    parser.add_argument("--list", action="store_true", help="List existing plans")
    parser.add_argument("--load", help="Load and display a specific plan")
    parser.add_argument("--config", help="Path to config file", default="agents/configs/config.json")
    
    args = parser.parse_args()
    
    planner = PlannerAgent(config_path=args.config)
    
    if args.list:
        plans = planner.list_plans()
        if plans:
            print("ðŸ“‹ Available plans:")
            for plan in plans:
                print(f"  - {plan}")
        else:
            print("No plans found.")
    elif args.load:
        plan = planner.load_plan(args.load)
        if plan:
            print(json.dumps(plan, indent=2))
        else:
            print(f"Plan not found: {args.load}")
    elif args.task:
        plan = planner.plan_task(args.task)
        print("\nðŸ“‹ Generated Plan:")
        print(json.dumps(plan, indent=2))
    else:
        parser.print_help()

if __name__ == "__main__":
    main()